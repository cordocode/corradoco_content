{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/cordo/Documents/corradoco_content/app/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\n\nexport const supabaseAdmin = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.SUPABASE_SERVICE_KEY!,\n  {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false,\n    },\n  }\n);"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,gBAAgB,IAAA,yMAAY,gFAEvC,QAAQ,GAAG,CAAC,oBAAoB,EAChC;IACE,MAAM;QACJ,kBAAkB;QAClB,gBAAgB;IAClB;AACF"}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"sources":["file:///Users/cordo/Documents/corradoco_content/app/api/queue/add/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { supabaseAdmin } from '@/app/lib/supabase';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { contentIds } = body;\n\n    // Get all pieces\n    const { data: pieces, error: fetchError } = await supabaseAdmin\n      .from('content_pieces')\n      .select('*')\n      .in('id', contentIds);\n\n    if (fetchError) throw fetchError;\n\n    // Get max positions for each type\n    const { data: maxPositions } = await supabaseAdmin\n      .from('content_pieces')\n      .select('type, queue_position')\n      .eq('status', 'queued')\n      .not('queue_position', 'is', null);\n\n    const maxLinkedIn = Math.max(0, ...maxPositions?.filter(p => p.type === 'linkedin').map(p => p.queue_position) || [0]);\n    const maxBlog = Math.max(0, ...maxPositions?.filter(p => p.type === 'blog').map(p => p.queue_position) || [0]);\n\n    let linkedInPos = maxLinkedIn;\n    let blogPos = maxBlog;\n\n    // Update each piece with queue position\n    const updates = pieces?.map(piece => {\n      const position = piece.type === 'linkedin' ? ++linkedInPos : ++blogPos;\n      return supabaseAdmin\n        .from('content_pieces')\n        .update({ \n          queue_position: position,\n          status: 'queued'\n        })\n        .eq('id', piece.id);\n    }) || [];\n\n    await Promise.all(updates);\n\n    return NextResponse.json({ success: true });\n  } catch (error) {\n    console.error('Error adding to queue:', error);\n    return NextResponse.json({ error: 'Failed to add to queue' }, { status: 500 });\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,UAAU,EAAE,GAAG;QAEvB,iBAAiB;QACjB,MAAM,EAAE,MAAM,MAAM,EAAE,OAAO,UAAU,EAAE,GAAG,MAAM,yIAAa,CAC5D,IAAI,CAAC,kBACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM;QAEZ,IAAI,YAAY,MAAM;QAEtB,kCAAkC;QAClC,MAAM,EAAE,MAAM,YAAY,EAAE,GAAG,MAAM,yIAAa,CAC/C,IAAI,CAAC,kBACL,MAAM,CAAC,wBACP,EAAE,CAAC,UAAU,UACb,GAAG,CAAC,kBAAkB,MAAM;QAE/B,MAAM,cAAc,KAAK,GAAG,CAAC,MAAM,cAAc,OAAO,CAAA,IAAK,EAAE,IAAI,KAAK,YAAY,IAAI,CAAA,IAAK,EAAE,cAAc,KAAK;YAAC;SAAE;QACrH,MAAM,UAAU,KAAK,GAAG,CAAC,MAAM,cAAc,OAAO,CAAA,IAAK,EAAE,IAAI,KAAK,QAAQ,IAAI,CAAA,IAAK,EAAE,cAAc,KAAK;YAAC;SAAE;QAE7G,IAAI,cAAc;QAClB,IAAI,UAAU;QAEd,wCAAwC;QACxC,MAAM,UAAU,QAAQ,IAAI,CAAA;YAC1B,MAAM,WAAW,MAAM,IAAI,KAAK,aAAa,EAAE,cAAc,EAAE;YAC/D,OAAO,yIAAa,CACjB,IAAI,CAAC,kBACL,MAAM,CAAC;gBACN,gBAAgB;gBAChB,QAAQ;YACV,GACC,EAAE,CAAC,MAAM,MAAM,EAAE;QACtB,MAAM,EAAE;QAER,MAAM,QAAQ,GAAG,CAAC;QAElB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAK;IAC3C,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAyB,GAAG;YAAE,QAAQ;QAAI;IAC9E;AACF"}}]
}